{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dyablo-Whole Sun documentation","text":"<p>Welcome to the documentation of Dyablo for the Whole-Sun branch and project.</p> <p></p>"},{"location":"#table-of-contents","title":"Table of contents","text":"<ul> <li>Equations</li> <li>Solvers</li> <li>Boundary conditions</li> <li>Tests and validation</li> <li>Setups<ul> <li>Convection slab</li> <li>Sandwich slab</li> <li>Triple layer</li> <li>Flux tube experiment</li> </ul> </li> <li>Benchmarks</li> </ul>"},{"location":"#todo-documentation","title":"TODO Documentation","text":"<p>Here is a list of things to do for the documentation </p> <ul> <li> Equations page</li> <li> Solvers page</li> <li> Boundary conditions page</li> <li> Tests and validation page</li> <li> Setups page</li> <li> Benchmark page</li> <li> Add a gallery of simulations</li> <li> Add references to equations page</li> <li> Add references to solvers page</li> <li> Linking to relevant parts of the code in solvers page</li> <li> Links to relevant parts of the code in setups page and tests page</li> <li> Include <code>.ini</code> parameters to sections when relevant</li> </ul>"},{"location":"about/","title":"About","text":"<p>TODO</p>"},{"location":"boundary_conditions/","title":"Boundary Conditions","text":"<p>The treatment of boundaries in Dyablo can be done in two ways : either by defining ghost values outside of the domain or by overriding the fluxes for each physical processes. Both methods are not incompatible and can be used together.</p>"},{"location":"boundary_conditions/#ghost-values","title":"Ghost values","text":"<p>The definition of ghost values is done in the <code>getUserdefBoundaryValue</code> method in <code>core/src/boundary_conditions/boundary_conditions.h</code>. The method has the following signature:</p> <pre><code>ConsState getUserdefBoundaryValue(const Uin_t               &amp;Uin, \n                                  const CellIndex           &amp;iCell_Boundary,\n                                  const CellIndex           &amp;iCell_Uin, \n                                  const CellMetaData        &amp;metadata, \n                                  const CellIndex::offset_t &amp;offset, \n                                  ComponentIndex3D           dir) const\n</code></pre> <p>The value returns a conservative state, and takes</p> <ul> <li><code>Uin</code> the fields array associated with these variables</li> <li><code>iCell_Boundary</code> the index of the (virtual) cell outside of the domain we are trying to fill</li> <li><code>iCell_Uin</code> the index of the reference cell (ie the closest cell in the domain)\\</li> <li><code>metadata</code> an object to query the cell sizes and positions in the mesh</li> <li><code>offset</code> the offset to apply to <code>iCell_Uin</code> to get <code>iCell_Boundary</code></li> <li><code>dir</code> the direction along which we got out of the domain (<code>IX</code>, <code>IY</code> or <code>IZ</code>)  </li> </ul> <p>This method is used for every physical treatment when using \"blocked\" solvers.</p>"},{"location":"boundary_conditions/#flux-override","title":"Flux override","text":"<p>The second method rewrites a given flux at the boundary. It is available for the hyperbolic flux, and for the thermal conduction kernels. No overriding is available yet for the viscous terms as they require cross-directional terms that are more complex to manage this way.</p>"},{"location":"boundary_conditions/#hyperbolic-flux","title":"Hyperbolic flux","text":"<p>Overriding the hyperbolic flux is done in the <code>overrideBoundaryFlux</code> method in <code>core/src/boundary_conditions/boundary_conditions.h</code>. The method has the following signature:</p> <pre><code>ConsState overrideBoundaryFlux(const typename State::ConsState flux_in, \n                               const typename State::PrimState q,\n                               const ComponentIndex3D          dir,\n                               const real_t                    ddir,\n                               const bool                      min_bound,\n                                     real_t                    p_out) const\n</code></pre> <p>The method expects a flux so a conservative variable structure. The function takes the following arguments:</p> <ul> <li><code>flux_in</code> the flux returned by the Riemann solver between the value in the cell and the value defined outside of the cell by the <code>getUserdefBoundaryValue</code>.</li> <li><code>q</code> the cell-centered primitive variables inside the domain</li> <li><code>dir</code> the direction along which we are trying to define the flux</li> <li><code>ddir</code> \\(1/\\Delta h\\) with \\(h\\) being the direction given by <code>dir</code></li> <li><code>min_bound</code> are we on \"left\" or the \"right\" of the domain. For instance, if <code>dir==IX</code> then <code>min_bound==true</code> means we're defining a flux at <code>xmin</code> and <code>min_bound==false</code> at <code>xmax</code></li> <li><code>p_out</code> the pressure at the interface, as recovered from the Riemann solver. </li> </ul>"},{"location":"boundary_conditions/#thermal-flux","title":"Thermal flux","text":"<p>For the thermal flux at the boundary, we can use the <code>overrideHeatFlux</code> method in <code>core/src/boundary_conditions/boundary_conditions.h</code></p> <p>As previously, the method has the following signature:</p> <pre><code>real_t overrideBoundaryHeatFlux(real_t                          flux_in,\n                                const typename State::PrimState q,\n                                const real_t                    kappa,\n                                const real_t                    dh,\n                                const ComponentIndex3D          dir,\n                                const bool                      min_bound) const\n</code></pre> <p>This time, the method only expects an energy flux as return value and not a whole conservative variable array. The method takes the following arguments:</p> <ul> <li><code>flux_in</code> the energy flux calculated by the thermal-conduction kernel using the <code>getUserdefBoundaryValue</code>.</li> <li><code>q</code> the cell-centered primitive variables</li> <li><code>kappa</code> the value of the thermal diffusion coefficient at the current position</li> <li><code>dh</code> the cell-size in the current direction</li> <li><code>dir</code> the current direction</li> <li><code>min_bound</code> see above.</li> </ul> <p>Note that by default, all flux overriding methods return their input flux, so if nothing is done precisely, we use by default the value in the ghost cells.</p>"},{"location":"boundary_conditions/#well-balancing","title":"Well-Balancing","text":"<p>In the case of a well-balanced run where the boundary conditions require an impenetrable wall in hydrostatic equilibrium, an additional treatment is done, and the fluxes are overriden once-more. The details of the treatment can be found in <code>core/src/hydro/HydroUpdate_utils.h</code>.</p> <p>In this case, the idea is to set the hydro flux to 0 everywhere, except for the moment term in the direction of the boundary. This part of the flux is originally written as : </p> \\[ F_{\\rho u} = \\rho u^2 + P \\] <p>Since we have a wall, \\(u=0\\), but we also wish to find the pressure \\(P\\) at the interface, to impose the hydrostatic equilibrium inside the domain. For this, we write the hydrostatic equilibrium :</p> \\[ \\nabla P = \\rho g \\] <p>Discretized as a centered finite-difference, this term can be rewritten as:</p> \\[ \\dfrac{P_R - P_L}{\\Delta x} = \\rho g \\] <p>Now, if we are the left boundary, then we know that \\(P_R\\) can be retrieved from the Riemann solver (or re-estimated) at the right interface of the cell, and we can find the value of the left pressure which is unknown:</p> \\[  P_L = P_R - \\Delta x \\rho g \\] <p>using the centered value of \\(\\rho\\) for that matter. Hence we redefine the normal momentum part of the flux as this value</p> \\[ F_{\\rho u} = P_L = P_R - \\Delta x \\rho g \\]"},{"location":"boundary_conditions/#mhd-boundary-conditions","title":"MHD Boundary conditions","text":"<p>Additionally for MHD fluxes, it is possible to define flux overrides independently of the hydro flux. For the moment, only two fluxes are available: </p> <ul> <li>normal-flux where the tangential field to the interface is null: \\(B_\\parallel = 0\\) </li> <li>perfect-conductor where the normal field to the interface is null: \\(B_\\perp = 0\\)</li> </ul> <p>These two boundary conditions require rewriting the flux correctly which can be tricky.</p>"},{"location":"boundary_conditions/#normal-flux","title":"Normal flux","text":"<p>In the case of a normal flux for the X interface, we have \\(B_y=B_z=0\\). Because we impose a transparent condition on the flux on \\(B_x\\) we have \\(B_{xm}=B_x\\) and we can take \\(\\psi_m=1/2\\psi\\) since we usually take \\(\\psi=0\\) outside of the box. Thus we have: </p> \\[ \\mathbf{F}_{normal\\_flux} = \\begin{pmatrix}  \\rho u \\\\  \\rho u^2 + P_{tot} - B_x^2 \\\\  \\rho uv \\\\  \\rho uw \\\\  (E_{tot}+P_{tot})u - B_x^2u\\\\   \\dfrac{1}{2}\\psi \\\\  B_xv \\\\  B_xw \\\\  ch^2 B_x \\end{pmatrix} \\] <p>Now we need to pay extra attention to the \\(E_{tot}\\) and \\(P_{tot}\\) terms that have been modified. In this case : </p> \\[ E_{tot} = \\dfrac{1}{2}\\rho||\\mathbf{u}||^2 + \\dfrac{1}{2}B_x^2 + \\rho e \\] <p>and</p> \\[ P_{tot} = P_{gas} + P_{mag} = P_{gas} + \\dfrac{1}{2}B_x^2 \\] <p>In the specific case where we need a well-balanced MHD run, then we have the following requirements: </p> <ul> <li>Parallel magnetic field is null: \\(B_y = B_z = 0\\).</li> <li>Normal velocity is null: \\(u=0\\).</li> <li>Gas pressure is reconstructed from HSE: \\(P_{gas} = P_R - \\Delta x \\rho g_x\\)</li> <li>Total pressure is thus: \\(P_{tot} = P_R - \\Delta x \\rho g_x + 1/2B_x^2\\)</li> <li>Finally the momentum flux follows: \\(P_{tot} - B_x^2 = P_R - \\Delta x \\rho g_x - 1/2B_x^2\\)</li> </ul> <p>Then the flux is written as follows:</p> \\[ \\mathbf{F}_{NFWB} = \\begin{pmatrix}  0 \\\\  P_R - \\Delta x \\rho g_x - \\dfrac{1}{2}B_x^2 \\\\  0 \\\\  0 \\\\  -B_x^2u\\\\   \\dfrac{1}{2}\\psi \\\\  -B_xv \\\\  -B_xw \\\\  ch^2 B_x \\end{pmatrix}  \\]"},{"location":"equations/","title":"Equations","text":""},{"location":"equations/#variables","title":"Variables","text":"<p>As of 2024, the Dyablo Whole-Sun branch solves the magnetohydrodynamics equations with viscosity and thermal conduction. The code evolves a set of equations expressed as conservative variables \\(\\mathbf{U}\\) or primitive variables \\(\\mathbf{Q}\\). </p> <p>The conservative variables are the following : </p> \\[ \\mathbf{U} = [\\rho, \\rho \\mathbf{u}, E_{tot}, \\mathbf{B}]^T \\] <p>with \\(\\rho\\) the density, \\(\\mathbf{u}\\) the fluid velocity, \\(E\\), the total energy and \\(\\mathbf{B}\\) the magnetic field. The total energy is expressed as </p> \\[ E_{tot} = E_{kin} + E_{mag} + \\rho e = \\dfrac{1}{2}\\rho\\mathbf{u}\\cdot\\mathbf{u} + \\dfrac{1}{2}\\mathbf{B}\\cdot\\mathbf{B} + \\rho e \\] <p>Where \\(e\\) is the internal energy defined by the equation of state.</p> <p>The primitive variables are defined as</p> \\[ \\mathbf{Q} = [\\rho, \\mathbf{u}, P_{tot}, \\mathbf{B}]^T \\] <p>where \\(P_tot\\) is the total pressure, defined as the sum of the fluid pressure \\(P\\) and the magnetic pressure:</p> \\[ P_{tot} = P_{gas} + P_{mag} = P_{gas} + \\dfrac{1}{2}\\mathbf{B}\\cdot\\mathbf{B} \\] <p>The conversion between the primitive and conservative variable is straight-forward except for the conversion between the total energy term and the total pressure term which requires an equation of state. For an ideal gas, we use the following relation : </p> \\[ e = \\dfrac{P_{gas}}{\\rho(\\gamma-1)} \\] <p>with \\(\\gamma\\) the specific heat ratio.</p>"},{"location":"equations/#equations_1","title":"Equations","text":"<p>The equations solved are generally of the form of conservation equations with source terms : </p> \\[ \\dfrac{\\partial \\mathbf{U}}{\\partial t} + \\nabla \\cdot \\mathbf{F}(\\mathbf{Q}) = \\mathbf{S}(\\mathbf{U}) \\] <p>where \\(\\mathbf{F}\\) is a flux expressed as a function of the primitive variables and \\(\\mathbf{S}\\) a source term.</p> <p>More precisely, the Whole-Sun branch evolves the following equations:</p> <ul> <li> <p>Conservation of mass $$ \\dfrac{\\partial \\rho}{\\partial t} + \\nabla\\cdot \\rho\\mathbf{u} = 0 $$</p> </li> <li> <p>Conservation of momentum  $$  \\dfrac{\\partial \\rho\\mathbf{u}}{\\partial t} + \\nabla \\cdot (\\rho\\mathbf{u}\\otimes\\mathbf{u} - \\mathbf{B}\\otimes\\mathbf{B} + P_{tot}\\mathbb{I} - \\nabla \\cdot \\tau) = \\rho\\mathbf{g}  $$</p> </li> </ul> <p>where \\(\\mathbb{I}\\) is the identity matrix, \\(\\tau\\) the viscosity tensor and \\(\\mathbf{g}\\) the gravitational acceleration. The viscosity tensor is a \\(ndim\\times ndim\\) matrix whose elements are defined as follows : </p> <p>$$  \\tau_{ij} = \\mu \\left(\\dfrac{\\partial u_i}{\\partial x_j} + \\dfrac{\\partial u_j}{\\partial x_i} - \\delta_i^j\\dfrac{2}{3}(\\nabla \\cdot \\mathbf{u})\\right)  $$  with \\(\\delta_i^j\\) being the Kroenecker delta and \\(\\mu\\) the (shear) dynamic viscosity coefficient. Bulk viscosity is set to zero for the moment.</p> <ul> <li>Conservation of energy  $$ \\dfrac{\\partial E_{tot}}{\\partial t} + \\nabla\\cdot([E_{tot}+P_{tot}]\\mathbf{u} - \\mathbf{B}(\\mathbf{B}\\cdot\\mathbf{u}) - \\tau\\cdot\\mathbf{u} - \\kappa \\nabla T) = \\rho\\mathbf{u}\\cdot \\mathbf{g} + \\mathcal{Q}  $$</li> </ul> <p>with \\(\\kappa\\) the thermal diffusion coefficient and \\(T\\) the temperature. For an ideal gas EOS we have \\(P = \\mathcal{R}\\rho T\\). We set \\(\\mathcal{R} = 1\\) and thus we retrieve the temperature from the primitive variables as \\(T = P_{gas}/\\rho\\). Additionally, a volumetric cooling/heating term can be added in \\(\\mathcal{Q}\\).</p> <ul> <li>Induction equation (ideal MHD)  $$  \\dfrac{\\partial \\mathbf{B}}{\\partial t} - \\nabla \\times (\\mathbf{u}\\times\\mathbf{B}) = 0  $$</li> </ul> <p>Finally, we also need to guarantee that numerically, no magnetic monopoles form :</p> <ul> <li>Solenoidal constraint</li> </ul> <p>$$  \\nabla \\cdot \\mathbf{B} = 0  $$</p>"},{"location":"equations/#hyperbolic-fluxes","title":"Hyperbolic fluxes","text":"<p>As mentioned previously, the general form of the equations takes the divergence of a flux and adds a source term. For a three-dimensional Cartesian grid, three fluxes intervene in the formulation of the equations, one along each direction:</p> \\[ \\dfrac{\\partial \\mathbf{U}}{\\partial t} + \\dfrac{\\partial \\mathbf{F}(\\mathbf{Q})}{\\partial x} + \\dfrac{\\partial\\mathbf{G}(\\mathbf{Q})}{\\partial y} + \\dfrac{\\partial \\mathbf{H}(\\mathbf{Q})}{\\partial z} = \\mathbf{S}(\\mathbf{U}) \\] <p>If we limit ourselves to the hyperbolic part of the equations, ignoring viscosity and thermal conduction, the fluxes are written as follows:</p> \\[ \\mathbf{F}(\\mathbf{Q}) =  \\begin{pmatrix}  \\rho u \\\\  \\rho u^2 + P_{tot} - B_x^2 \\\\  \\rho uv - B_xB_y \\\\  \\rho uw - B_xB_z \\\\  (E_{tot}+P_{tot})u - B_x(\\mathbf{u}\\cdot\\mathbf{B})\\\\   0 \\\\  B_yu - B_xv \\\\  B_zu - B_xw \\end{pmatrix} \\] \\[ \\mathbf{G}(\\mathbf{Q}) =  \\begin{pmatrix}  \\rho v \\\\  \\rho uv - B_yB_x\\\\  \\rho v^2 + P_{tot} - B_y^2 \\\\  \\rho uw - B_yB_z \\\\  (E_{tot}+P_{tot})v - B_y(\\mathbf{u}\\cdot\\mathbf{B})\\\\   B_xv - B_yu \\\\  0 \\\\  B_zv - B_yw \\end{pmatrix} \\] \\[ \\mathbf{H}(\\mathbf{Q}) =  \\begin{pmatrix}  \\rho w \\\\  \\rho uw - B_zB_x\\\\  \\rho vw - B_zB_y\\\\  \\rho w^2 + P_{tot} - B_z^2 \\\\  (E_{tot}+P_{tot})w - B_z(\\mathbf{u}\\cdot\\mathbf{B})\\\\   B_xw - B_zu \\\\  B_yw - B_zv \\\\  0 \\end{pmatrix} \\]"},{"location":"equations/#source-terms","title":"Source Terms","text":"<p>For now, the only source terms added in the simulation are the gravitational effects, and potential cooling. The source term vector takes the following form :</p> \\[ \\mathbf{S}(\\mathbf{U}) =  \\begin{pmatrix} 0\\\\ \\rho g_x\\\\ \\rho g_y\\\\ \\rho g_z\\\\ \\rho \\mathbf{u}\\cdot\\mathbf{g} + \\mathcal{Q}\\\\ 0\\\\ 0\\\\ 0\\\\ \\end{pmatrix} \\]"},{"location":"equations/#future-considerations","title":"Future considerations","text":"<p>For the future of the project, additional terms will have to be taken into account:</p> <ul> <li>Non-ideal MHD : Resistivity, Hall-effect and Ambipolar diffusion</li> <li>Radiative transfer : Moments, short-characteristics, or Monte-Carlo</li> <li>Non-ideal equations of state</li> <li>Rotation : f-plane and full domain rotation with sphere mapping</li> <li>Forcing term for the magnetic field</li> <li>Potential boundary-conditions</li> <li>Multi-species</li> </ul>"},{"location":"solvers/","title":"Solvers and discretization","text":"<p>This page describes the solver implemented in Dyablo-Whole Sun.</p>"},{"location":"solvers/#discretization","title":"Discretization","text":"<p>We employ a finite-volume discretization of space. Considering a physical solution for the equations under the form of a conservative variable vector space $\\mathbf{\\tilde{U(x, y, z, t)}} defined on every point of space at a given time \\(t\\) we represent the solution as volume averages on a (adaptive) grid. For an element \\(\\mathbf{i}\\) of this grid spanning from \\([x_{\\mathbf{i}-(1/2,0,0)}, y_{\\mathbf{i}-(0,1/2,0)}, z_{\\mathbf{i}-(0,0,1/2)}]\\) to \\([x_{\\mathbf{i}+(1/2,0,0)}, y_{\\mathbf{i}+(0,1/2,0)}, z_{\\mathbf{i}+(0,0,1/2)}]\\) we approximate the physical solution as :</p> \\[ \\mathbf{U}_{\\mathbf{i}}(t) = \\dfrac{1}{V_{\\mathbf{i}}}\\int\\int\\int \\mathbf{\\tilde{U}}(x, y, z, t)dxdydz \\] <p>Where \\(V_{\\mathbf{i}}\\) is the volume of the element of the grid at index \\(\\mathbf{i}\\)</p>"},{"location":"solvers/#time-stepping","title":"Time stepping","text":"<p>For now, only explicit time-stepping is available in Dyablo. The calculations splits the hyperbolic, the parabolic and the source terms in different updates. We use operator splitting operations to separate all treatments. The two solvers available for now are a first order forward Euler method and a strong-stability preserving second order Runge-Kutta scheme. To evolve from a time given at iteration \\(n\\) to the next iteration \\(n+1\\) at time \\(t+\\Delta t\\), we write the semi-discretized formulation for the hyperbolic terms of these schemes as the following [the formulation stays similar for the parabolic and source terms]:</p> <p>First order Euler integrator:</p> \\[ \\mathbf{U}^{n+1}_\\mathbf{i} = \\mathbf{U}^n_\\mathbf{i} - \\Delta t (\\nabla \\cdot \\mathbf{F}(\\mathbf{U}_\\mathbf{i})) \\] <p>Second order strong-stability preserving Runge-Kutta:</p> \\[ \\mathbf{U}^*_\\mathbf{i} = \\mathbf{U}^n_\\mathbf{i} - \\Delta t (\\nabla \\cdot \\mathbf{F}(\\mathbf{U})) \\\\ \\mathbf{U}^{n+1}_\\mathbf{i} = \\dfrac{1}{2}(\\mathbf{U}^n_\\mathbf{i} + \\mathbf{U}^*_\\mathbf{i} - \\Delta t (\\nabla \\cdot \\mathbf{F}(\\mathbf{U^*_\\mathbf{i}}))) \\]"},{"location":"solvers/#hyperbolic-flux-calculation","title":"Hyperbolic flux calculation","text":"<p>In order to solve the hyperbolic terms, we need to calculate the divergence of the flux. For this, we employ the Godunov method and use the divergence theorem to rewrite the evolution equation as the sum of the fluxes on the areas of the cell. We orient the fluxes toward the positive axes of the Cartesian domain, and thus, a positive flux on the \"left\" of a cell means \"entering flux\" while a positive flux on the \"right\" of a cell means \"exiting flux\". To simplify the following, we write the discretization in 1D but the 2D and 3D cases are discretized similarly along each directions:</p> \\[ \\dfrac{\\partial \\mathbf{F}(\\mathbf{U}_i^n)}{\\partial x} = \\dfrac{1}{V_i}(A^x_{i-1/2} \\mathbf{F}(\\mathbf{U}_{i-1/2}) - A^x_{i+1/2} \\mathbf{F}(\\mathbf{U}_{i+1/2})) \\] <p>where \\(A^x_{i-1/2}\\) is the area on the left face along the x direction, and similarly for the right face. Note that since Dyablo is using adaptive mesh refinement, in the case where the neighbor is non conformal and multiple, the left and/or right terms are representing a sum of fluxes multiplied by their corresponding areas.</p> <p>To simplify the following notations we write the flux at the interface as: </p> \\[ \\mathbf{F}_{i-1/2} := \\mathbf{F}(\\mathbf{U}^n_{i-1/2}) \\] <p>Every update along each direction is done at the same time in the unsplit Godunov way. If we were to write the complete update for the first order Euler timestepping on a regular 3D grid as an example, this would give:</p> \\[ \\begin{split} \\mathbf{U}^{n+1}_i = \\mathbf{U}^n_i &amp;+ \\dfrac{\\Delta t}{\\Delta x}(\\mathbf{F}_{i-1/2} - \\mathbf{F}_{i+1/2}) \\\\                                      &amp;+ \\dfrac{\\Delta t}{\\Delta y}(\\mathbf{G}_{j-1/2} - \\mathbf{G}_{j+1/2}) \\\\                                     &amp;+ \\dfrac{\\Delta t}{\\Delta z}(\\mathbf{H}_{k-1/2} - \\mathbf{H}_{k+1/2}) \\end{split} \\] <p>Where we only write the relevant indices for the fluxes. Also it is important to note here that the volume and area terms can be simplified since the grid is regular. This is not the case in AMR anymore where one flux can be the sum of multiple smaller fluxes in the case of a non-conformal neighbor. </p> <p>To calculate the update, we are left with the calculation of the values of the fluxes at the interfaces along each direction. To do this, we solve the Riemann problem at the interface between the primitive state on the left of the interface (\\(\\mathbf{Q}_L\\)) and the primitive state on the right of the interface (\\(\\mathbf{Q}_R\\)) : </p> \\[ \\mathbf{F}_{i-1/2} = \\mathbf{F}(\\mathcal{R}(\\mathbf{Q}^n_L, \\mathbf{Q}^n_R)) \\] <p>The Riemann solvers implemented in Dyablo are: </p> <ul> <li>HLLC (Toro 2009) for Hydrodynamics problems</li> <li>HLLD (Miyoshi, Kusano 2005) for MHD problems</li> <li>Five-Waves (Bourgeois in prep 2024) for MHD problems</li> </ul>"},{"location":"solvers/#interface-values","title":"Interface values","text":"<p>The reconstruction of the values at the interfaces before the resolution of the Riemann problem can be picked among three choices : </p> <ul> <li>Piecewise constant method (order 1): \\(\\mathbf{Q}_{i-1/2} = \\mathbf{Q}_i\\)</li> <li>Piecewise linear method (order 2): \\(\\mathbf{Q}_{i-1/2} = \\mathbf{Q}_i - \\dfrac{\\Delta x}{2}\\mathbf{S}_x\\), with \\(\\mathbf{S}_x\\) a limited slope, as defined later.</li> <li>Well-balanced (order 1) (Kappelli 2012), which uses a piecewise constant method for all the variables except the pressure which is reconstructed to guarantee hydrostatic equilibrium : \\(P_{gas, i-1/2} = P_{gas, i} - \\rho_i g \\dfrac{\\Delta x}{2}\\). With \\(g\\) the value of the gravitational acceleration along that direction.</li> </ul> <p>The slope \\(\\mathbf{S}_x\\) is calculated using the slope on the left, and the right of the cell, and is then limited: </p> \\[ \\begin{split}   \\mathbf{S}_x^L &amp;= \\dfrac{\\mathbf{Q}_i-\\mathbf{Q}_{i-1}}{\\Delta x} \\\\   \\mathbf{S}_x^R &amp;= \\dfrac{\\mathbf{Q}_{i+1}-\\mathbf{Q}_{i}}{\\Delta x} \\\\   \\mathbf{S}_x &amp;= \\Phi(\\mathbf{S}_x^L, \\mathbf{S}_x^R) \\end{split} \\] <p>with \\(\\Phi(a, b)\\) a slope limiter. Currently, in the Whole-Sun branch, only a minmod limiter is available:</p> \\[ \\Phi_{minmod}(a, b) = \\begin{cases}   0 &amp;\\text{if } ab &lt; 0 \\\\   a &amp;\\text{if } |a| &lt; |b| \\\\   b &amp;\\text{else} \\end{cases} \\]"},{"location":"solvers/#solenoidal-constraint","title":"Solenoidal constraint","text":"<p>To guarantee the solenoidal constraint \\(\\nabla\\cdot \\mathbf{B}=0\\) we need to implement additional mechanisms. For now in Dyablo, two solutions are implemented:</p> <ul> <li>Using an entropy-preserving scheme (Five-Waves) to make sure \\(\\nabla \\cdot \\mathbf{B}\\) stays low and bounded.</li> <li>Using a Generalized Lagrange Method (GLM) for MHD (Dedner 2002).</li> </ul> <p>In the case of GLM-MHD, we need to include one additional variable \\(\\psi\\) that will account for the numerical error in \\(\\nabla\\cdot\\mathbf{B}\\). The numerical scheme will then advect out of the domain (hyperbolic cleaning) and diffuse (parabolic cleaning). In practice, this requires to slightly modify the equations solved. Thus, the new conservative variable, primitive variable and associated flux become:</p> \\[ \\begin{split} \\mathbf{U} &amp;= [\\rho, \\rho \\mathbf{u}, E_{tot}, \\mathbf{B}, \\psi]^T\\\\ \\mathbf{Q} &amp;= [\\rho, \\mathbf{u}, P_{tot}, \\mathbf{B}, \\psi]^T \\\\ \\end{split} \\] \\[ \\mathbf{F}(\\mathbf{Q}) =  \\begin{pmatrix}  \\rho u \\\\  \\rho u^2 + P_{tot} - B_x^2 \\\\  \\rho uv - B_xB_y \\\\  \\rho uw - B_xB_z \\\\  (E_{tot}+P_{tot})u - B_z(\\mathbf{u}\\cdot\\mathbf{B})\\\\   \\psi_m \\\\  B_yu - B_xv \\\\  B_zu - B_xw \\\\  ch^2 B_{xm} \\end{pmatrix} \\] <p>With \\(c_h\\) an hyperbolic cleaning constant that can be seen as an advection velocity. The values with subscripts \\(m\\) are simply defined as the average between the quantities on each side of the interface when solving the Riemann problem.</p> <p>Parabolic cleaning is done outside of the hyperbolic step and is straightforward: </p> \\[ \\psi^{n+1}_i = \\psi^{n*}e^{-\\Delta t c_h^2/c_p^2} \\] <p>With \\(\\psi^{n*}\\) the value of \\(\\psi\\) in the cell after the hyperbolic update and \\(c_p\\) a diffusion coefficient. As per (Dedner 2002) we set </p> \\[ c_h := \\dfrac{C}{\\Delta t}\\min_{d={x,y,z}}(\\Delta d) \\] <p>where \\(C\\) is the limiting constant associated with the MHD CFL calculation. </p> <p>To define \\(c_p\\) we use a proxy parameter \\(c_r\\) defined by the user, and such that </p> \\[ c_p = \\sqrt{c_rc_h} \\] <p>The value of \\(c_r\\) is left to the user, but by default is set to \\(0.1\\) (see discussion after eq (46) in (Dedner 2002) for more information on this parameter).</p>"},{"location":"solvers/#timestep-calculation","title":"Timestep calculation","text":"<p>TODO</p>"},{"location":"solvers/#flux-formulation-of-the-thermal-conduction-and-viscosity-terms","title":"Flux formulation of the thermal conduction and viscosity terms:","text":"<p>TODO</p>"},{"location":"solvers/#solvers-implementation","title":"Solvers implementation","text":"<p>TODO</p>"},{"location":"solvers/#future-considerations","title":"Future considerations","text":"<ul> <li>Implicit solvers for parabolic treatments</li> <li>2nd order well-balanced scheme</li> <li>All-Mach schemes</li> <li>Constraint-Transport</li> </ul>"},{"location":"solvers/#references","title":"References","text":""}]}